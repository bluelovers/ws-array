"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function arrayChunkMap(options) {
    const { inputArray, maxChunkLength, maxChunkSize } = options;
    let { mapMethod } = options;
    let result;
    if (maxChunkLength != null) {
        result = arrayChunkSplit(inputArray, maxChunkLength);
    }
    else if (maxChunkSize != null) {
        result = arrayChunkBySize(inputArray, maxChunkSize);
    }
    else {
        throw new TypeError(`maxChunkLength or maxChunkSize is required`);
    }
    if (typeof mapMethod != 'function') {
        if (mapMethod) {
            mapMethod = (value) => value[value.length - 1];
        }
        else {
            mapMethod = (value) => value[0];
        }
    }
    return result.map(mapMethod);
}
exports.arrayChunkMap = arrayChunkMap;
/**
 * Split an array into arrays of chunk with max size
 *
 * @example arrayChunkBySize([1, 2, 3, 4, 5, 6, 7, 8], 5); // => [[1, 2, 3, 4, 5], [6, 7, 8]]
 */
function arrayChunkBySize(arr, maxChunkSize) {
    const result = [];
    //let part: T[] = [];
    const { length } = arr;
    if (typeof maxChunkSize !== 'number' || maxChunkSize < 1) {
        throw new RangeError(`expected maxChunkSize > 0 but got ${maxChunkSize}`);
    }
    for (let i = 0; i < length; i++) {
        let next = i + maxChunkSize;
        result.push(arr.slice(i, next));
        i = next - 1;
    }
    return result;
}
exports.arrayChunkBySize = arrayChunkBySize;
/**
 * Split an array into arrays with max chunk length
 *
 * @example arrayChunkSplit([1, 2, 3, 4, 5, 6, 7, 8], 4); // => [[1, 2], [3, 4], [5, 6], [7, 8]]
 */
function arrayChunkSplit(arr, maxChunkLength) {
    if (typeof maxChunkLength !== 'number' || maxChunkLength < 1) {
        throw new RangeError(`expected maxChunkLength > 0 but got ${maxChunkLength}`);
    }
    const maxChunkSize = Math.max(Math.round(arr.length / maxChunkLength), 1);
    return arrayChunkBySize(arr, maxChunkSize);
}
exports.arrayChunkSplit = arrayChunkSplit;
exports.default = arrayChunkSplit;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQXlFQSxTQUFnQixhQUFhLENBQVcsT0FFdkM7SUFFQSxNQUFNLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxZQUFZLEVBQUUsR0FBRyxPQUFPLENBQUM7SUFDN0QsSUFBSSxFQUFFLFNBQVMsRUFBRSxHQUFHLE9BQU8sQ0FBQztJQUU1QixJQUFJLE1BQXNCLENBQUM7SUFFM0IsSUFBSSxjQUFjLElBQUksSUFBSSxFQUMxQjtRQUNDLE1BQU0sR0FBRyxlQUFlLENBQUMsVUFBVSxFQUFFLGNBQWMsQ0FBQyxDQUFDO0tBQ3JEO1NBQ0ksSUFBSSxZQUFZLElBQUksSUFBSSxFQUM3QjtRQUNDLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsWUFBWSxDQUFDLENBQUM7S0FDcEQ7U0FFRDtRQUNDLE1BQU0sSUFBSSxTQUFTLENBQUMsNENBQTRDLENBQUMsQ0FBQTtLQUNqRTtJQUVELElBQUksT0FBTyxTQUFTLElBQUksVUFBVSxFQUNsQztRQUNDLElBQUksU0FBUyxFQUNiO1lBQ0MsU0FBUyxHQUFHLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztTQUMvQzthQUVEO1lBQ0MsU0FBUyxHQUFHLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDaEM7S0FDRDtJQUVELE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQWUsQ0FBQztBQUM1QyxDQUFDO0FBbkNELHNDQW1DQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQixnQkFBZ0IsQ0FBSSxHQUFRLEVBQUUsWUFBb0I7SUFFakUsTUFBTSxNQUFNLEdBQW1CLEVBQUUsQ0FBQztJQUNsQyxxQkFBcUI7SUFFckIsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQztJQUV2QixJQUFJLE9BQU8sWUFBWSxLQUFLLFFBQVEsSUFBSSxZQUFZLEdBQUcsQ0FBQyxFQUN4RDtRQUNDLE1BQU0sSUFBSSxVQUFVLENBQUMscUNBQXFDLFlBQVksRUFBRSxDQUFDLENBQUE7S0FDekU7SUFFRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUMvQjtRQUNDLElBQUksSUFBSSxHQUFHLENBQUMsR0FBRyxZQUFZLENBQUM7UUFFNUIsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBRWhDLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0tBQ2I7SUFFRCxPQUFPLE1BQU0sQ0FBQztBQUNmLENBQUM7QUF0QkQsNENBc0JDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLGVBQWUsQ0FBSSxHQUFRLEVBQUUsY0FBc0I7SUFFbEUsSUFBSSxPQUFPLGNBQWMsS0FBSyxRQUFRLElBQUksY0FBYyxHQUFHLENBQUMsRUFDNUQ7UUFDQyxNQUFNLElBQUksVUFBVSxDQUFDLHVDQUF1QyxjQUFjLEVBQUUsQ0FBQyxDQUFBO0tBQzdFO0lBRUQsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsY0FBYyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDMUUsT0FBTyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsWUFBWSxDQUFDLENBQUM7QUFDNUMsQ0FBQztBQVRELDBDQVNDO0FBRUQsa0JBQWUsZUFBZSxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSVRTUmVxdWlyZUF0TGVhc3RPbmUgfSBmcm9tICd0cy10eXBlJztcblxuLyoqXG4gKiBzYW1lIGFzIFRbXVtdXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUNodW5rQXJyYXk8VD4gZXh0ZW5kcyBBcnJheTxUW10+XG57XG5cbn1cblxuLyoqXG4gKiB3aWxsIGNhbGxzIGEgZGVmaW5lZCBjYWxsYmFjayBmdW5jdGlvbiBvbiBlYWNoIGVsZW1lbnQgb2YgYW4gYXJyYXksIGFuZCByZXR1cm5zIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdHMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSU1hcENhbGxiYWNrPFQsIFIgPSBUPlxue1xuXHQodmFsdWU6IFRbXSwgaW5kZXg6IG51bWJlciwgYXJyYXk6IElDaHVua0FycmF5PFQ+KTogUlxuXG5cdCh2YWx1ZTogVFtdLCBpbmRleDogbnVtYmVyLCBhcnJheTogSUNodW5rQXJyYXk8VD4pOiBUXG59XG5cbmV4cG9ydCB0eXBlIElPcHRpb25zPFQ+ID0ge1xuXG5cdC8qKlxuXHQgKiBzb3VyY2UgYXJyYXlcblx0ICovXG5cdGlucHV0QXJyYXk6IFRbXSxcblxufSAmIElUU1JlcXVpcmVBdExlYXN0T25lPHtcblxuXHQvKipcblx0ICogU3BsaXQgYW4gYXJyYXkgaW50byBhcnJheXMgd2l0aCBtYXggY2h1bmsgbGVuZ3RoXG5cdCAqL1xuXHRtYXhDaHVua0xlbmd0aD86IG51bWJlcixcblx0LyoqXG5cdCAqIFNwbGl0IGFuIGFycmF5IGludG8gYXJyYXlzIG9mIGNodW5rIHdpdGggbWF4IHNpemVcblx0ICovXG5cdG1heENodW5rU2l6ZT86IG51bWJlcixcblxufSwgJ21heENodW5rTGVuZ3RoJyB8ICdtYXhDaHVua1NpemUnPjtcblxuLyoqXG4gKiBieSBkZWZhdWx0IHdpbGwgcmV0dXJuIGEgYXJyYXkgd2l0aCBmaXJzdCB2YWx1ZSBpbiBjaHVua1xuICpcbiAqIGlmIG1hcE1ldGhvZCA9IHRydWUgd2lsbCByZXR1cm4gbGFzdCB2YWx1ZSBvZiBjaHVua1xuICpcbiAqIGlmIGdpdmUgbWFwTWV0aG9kIGlzIGZ1bmN0aW9uXG4gKiB3aWxsIGNhbGxzIGEgZGVmaW5lZCBjYWxsYmFjayBmdW5jdGlvbiBvbiBlYWNoIGVsZW1lbnQgb2YgYW4gYXJyYXksIGFuZCByZXR1cm5zIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUNodW5rTWFwPFQsIFIgPSBUPihvcHRpb25zOiBJT3B0aW9uczxUPiAmIHtcblx0bWFwTWV0aG9kOiBJTWFwQ2FsbGJhY2s8VCwgUj5cbn0pOiBSW11cbi8qKlxuICogYnkgZGVmYXVsdCB3aWxsIHJldHVybiBhIGFycmF5IHdpdGggZmlyc3QgdmFsdWUgaW4gY2h1bmtcbiAqXG4gKiBpZiBtYXBNZXRob2QgPSB0cnVlIHdpbGwgcmV0dXJuIGxhc3QgdmFsdWUgb2YgY2h1bmtcbiAqXG4gKiBpZiBnaXZlIG1hcE1ldGhvZCBpcyBmdW5jdGlvblxuICogd2lsbCBjYWxscyBhIGRlZmluZWQgY2FsbGJhY2sgZnVuY3Rpb24gb24gZWFjaCBlbGVtZW50IG9mIGFuIGFycmF5LCBhbmQgcmV0dXJucyBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlDaHVua01hcDxUPihvcHRpb25zOiBJT3B0aW9uczxUPiAmIHtcblx0bWFwTWV0aG9kOiBib29sZWFuXG59KTogVFtdXG4vKipcbiAqIGJ5IGRlZmF1bHQgd2lsbCByZXR1cm4gYSBhcnJheSB3aXRoIGZpcnN0IHZhbHVlIGluIGNodW5rXG4gKlxuICogaWYgbWFwTWV0aG9kID0gdHJ1ZSB3aWxsIHJldHVybiBsYXN0IHZhbHVlIG9mIGNodW5rXG4gKlxuICogaWYgZ2l2ZSBtYXBNZXRob2QgaXMgZnVuY3Rpb25cbiAqIHdpbGwgY2FsbHMgYSBkZWZpbmVkIGNhbGxiYWNrIGZ1bmN0aW9uIG9uIGVhY2ggZWxlbWVudCBvZiBhbiBhcnJheSwgYW5kIHJldHVybnMgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFycmF5Q2h1bmtNYXA8VCwgUiA9IFQ+KG9wdGlvbnM6IElPcHRpb25zPFQ+ICYge1xuXHRtYXBNZXRob2Q/OiBib29sZWFuIHwgSU1hcENhbGxiYWNrPFQsIFI+XG59KTogUltdXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlDaHVua01hcDxULCBSID0gVD4ob3B0aW9uczogSU9wdGlvbnM8VD4gJiB7XG5cdG1hcE1ldGhvZD86IGJvb2xlYW4gfCBJTWFwQ2FsbGJhY2s8VCwgUj5cbn0pOiBSW11cbntcblx0Y29uc3QgeyBpbnB1dEFycmF5LCBtYXhDaHVua0xlbmd0aCwgbWF4Q2h1bmtTaXplIH0gPSBvcHRpb25zO1xuXHRsZXQgeyBtYXBNZXRob2QgfSA9IG9wdGlvbnM7XG5cblx0bGV0IHJlc3VsdDogSUNodW5rQXJyYXk8VD47XG5cblx0aWYgKG1heENodW5rTGVuZ3RoICE9IG51bGwpXG5cdHtcblx0XHRyZXN1bHQgPSBhcnJheUNodW5rU3BsaXQoaW5wdXRBcnJheSwgbWF4Q2h1bmtMZW5ndGgpO1xuXHR9XG5cdGVsc2UgaWYgKG1heENodW5rU2l6ZSAhPSBudWxsKVxuXHR7XG5cdFx0cmVzdWx0ID0gYXJyYXlDaHVua0J5U2l6ZShpbnB1dEFycmF5LCBtYXhDaHVua1NpemUpO1xuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYG1heENodW5rTGVuZ3RoIG9yIG1heENodW5rU2l6ZSBpcyByZXF1aXJlZGApXG5cdH1cblxuXHRpZiAodHlwZW9mIG1hcE1ldGhvZCAhPSAnZnVuY3Rpb24nKVxuXHR7XG5cdFx0aWYgKG1hcE1ldGhvZClcblx0XHR7XG5cdFx0XHRtYXBNZXRob2QgPSAodmFsdWUpID0+IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0bWFwTWV0aG9kID0gKHZhbHVlKSA9PiB2YWx1ZVswXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0Lm1hcChtYXBNZXRob2QpIGFzIGFueSBhcyBSW107XG59XG5cbi8qKlxuICogU3BsaXQgYW4gYXJyYXkgaW50byBhcnJheXMgb2YgY2h1bmsgd2l0aCBtYXggc2l6ZVxuICpcbiAqIEBleGFtcGxlIGFycmF5Q2h1bmtCeVNpemUoWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDhdLCA1KTsgLy8gPT4gW1sxLCAyLCAzLCA0LCA1XSwgWzYsIDcsIDhdXVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlDaHVua0J5U2l6ZTxUPihhcnI6IFRbXSwgbWF4Q2h1bmtTaXplOiBudW1iZXIpOiBJQ2h1bmtBcnJheTxUPlxue1xuXHRjb25zdCByZXN1bHQ6IElDaHVua0FycmF5PFQ+ID0gW107XG5cdC8vbGV0IHBhcnQ6IFRbXSA9IFtdO1xuXG5cdGNvbnN0IHsgbGVuZ3RoIH0gPSBhcnI7XG5cblx0aWYgKHR5cGVvZiBtYXhDaHVua1NpemUgIT09ICdudW1iZXInIHx8IG1heENodW5rU2l6ZSA8IDEpXG5cdHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZXhwZWN0ZWQgbWF4Q2h1bmtTaXplID4gMCBidXQgZ290ICR7bWF4Q2h1bmtTaXplfWApXG5cdH1cblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuXHR7XG5cdFx0bGV0IG5leHQgPSBpICsgbWF4Q2h1bmtTaXplO1xuXG5cdFx0cmVzdWx0LnB1c2goYXJyLnNsaWNlKGksIG5leHQpKTtcblxuXHRcdGkgPSBuZXh0IC0gMTtcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogU3BsaXQgYW4gYXJyYXkgaW50byBhcnJheXMgd2l0aCBtYXggY2h1bmsgbGVuZ3RoXG4gKlxuICogQGV4YW1wbGUgYXJyYXlDaHVua1NwbGl0KFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4XSwgNCk7IC8vID0+IFtbMSwgMl0sIFszLCA0XSwgWzUsIDZdLCBbNywgOF1dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUNodW5rU3BsaXQ8VD4oYXJyOiBUW10sIG1heENodW5rTGVuZ3RoOiBudW1iZXIpXG57XG5cdGlmICh0eXBlb2YgbWF4Q2h1bmtMZW5ndGggIT09ICdudW1iZXInIHx8IG1heENodW5rTGVuZ3RoIDwgMSlcblx0e1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGBleHBlY3RlZCBtYXhDaHVua0xlbmd0aCA+IDAgYnV0IGdvdCAke21heENodW5rTGVuZ3RofWApXG5cdH1cblxuXHRjb25zdCBtYXhDaHVua1NpemUgPSBNYXRoLm1heChNYXRoLnJvdW5kKGFyci5sZW5ndGggLyBtYXhDaHVua0xlbmd0aCksIDEpO1xuXHRyZXR1cm4gYXJyYXlDaHVua0J5U2l6ZShhcnIsIG1heENodW5rU2l6ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5Q2h1bmtTcGxpdFxuIl19